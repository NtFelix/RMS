name: Lighthouse CI

on:
  pull_request:
    branches: [main, develop]
    types: [opened, reopened, synchronize]
  push:
    branches: [main]
  workflow_dispatch:  # Allows manual triggering from the Actions tab

jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      build-cache-key: ${{ steps.build-cache-key.outputs.cache-key }}
      should-run-lighthouse: ${{ steps.check-trigger.outputs.should-run }}
    
    steps:
      - name: Check if Lighthouse should run
        id: check-trigger
        run: |
          # Run Lighthouse on:
          # 1. PR opened/reopened (not on every push to PR)
          # 2. Push to main (merge)
          # 3. Manual workflow dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "Reason: Manual trigger"
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "Reason: Push to main"
          elif [[ "${{ github.event_name }}" == "pull_request" && ("${{ github.event.action }}" == "opened" || "${{ github.event.action }}" == "reopened") ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "Reason: PR opened/reopened"
          else
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "Reason: Regular PR update - skipping Lighthouse"
          fi
    
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate build cache key
        id: build-cache-key
        run: |
          # Create a hash of all files that affect the build
          BUILD_HASH=$(find app components lib hooks types utils public -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" -o -name "*.css" -o -name "*.json" \) -exec sha256sum {} \; 2>/dev/null | sort | sha256sum | cut -d' ' -f1 || echo "no-files")
          PACKAGE_HASH="${{ hashFiles('**/package-lock.json', '**/package.json', 'next.config.js', 'tsconfig.json', 'tailwind.config.ts') }}"
          CACHE_KEY="build-${BUILD_HASH}-${PACKAGE_HASH}"
          echo "cache-key=${CACHE_KEY}" >> $GITHUB_OUTPUT
          echo "Build cache key: ${CACHE_KEY}"

      - name: Restore build cache
        id: restore-build-cache
        uses: actions/cache/restore@v4
        with:
          path: .next
          key: ${{ steps.build-cache-key.outputs.cache-key }}
          restore-keys: |
            build-

      - name: Cache node_modules
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install dependencies
        if: steps.restore-build-cache.outputs.cache-hit != 'true' && steps.cache-node-modules.outputs.cache-hit != 'true'
        run: npm ci --prefer-offline

      - name: Build application
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        run: npm run build

      - name: Save build cache
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: .next
          key: ${{ steps.build-cache-key.outputs.cache-key }}

      - name: Build status
        run: |
          if [ "${{ steps.restore-build-cache.outputs.cache-hit }}" == "true" ]; then
            echo "‚úì Build restored from cache"
          else
            echo "‚úì Build completed and cached"
          fi

  lighthouse:
    name: Lighthouse Audit (${{ matrix.device }})
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.should-run-lighthouse == 'true'
    timeout-minutes: 10
    
    strategy:
      fail-fast: false
      matrix:
        device: [mobile, desktop, tablet]
        include:
          - device: mobile
            form-factor: mobile
            port: 3001
          - device: desktop
            form-factor: desktop
            port: 3002
          - device: tablet
            form-factor: mobile
            port: 3003
            viewport-width: 768
            viewport-height: 1024
    
    permissions:
      contents: read

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Restore build cache
        uses: actions/cache/restore@v4
        with:
          path: .next
          key: ${{ needs.build.outputs.build-cache-key }}
          restore-keys: |
            build-
          fail-on-cache-miss: true

      - name: Cache Lighthouse CI tools
        id: cache-lighthouse-tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            node_modules/@lhci
            node_modules/wait-on
            node_modules/.bin/lhci
            node_modules/.bin/wait-on
          key: ${{ runner.os }}-lighthouse-tools-${{ hashFiles('**/package-lock.json') }}-v1
          restore-keys: |
            ${{ runner.os }}-lighthouse-tools-

      - name: Install Lighthouse CI tools
        if: steps.cache-lighthouse-tools.outputs.cache-hit != 'true'
        run: npm install --no-save @lhci/cli wait-on

      - name: Verify Lighthouse CI tools
        run: |
          if [ "${{ steps.cache-lighthouse-tools.outputs.cache-hit }}" == "true" ]; then
            echo "‚úì Lighthouse CI tools restored from cache"
          else
            echo "‚úì Lighthouse CI tools installed"
          fi
          npx lhci --version
          npx wait-on --version

      - name: Run Lighthouse audit
        id: lighthouse
        timeout-minutes: 8
        run: |
          DEVICE="${{ matrix.device }}"
          FORM_FACTOR="${{ matrix.form-factor }}"
          PORT="${{ matrix.port }}"
          VIEWPORT_WIDTH="${{ matrix.viewport-width }}"
          VIEWPORT_HEIGHT="${{ matrix.viewport-height }}"
          
          echo "Running Lighthouse audit for $DEVICE..."
          echo "Working directory: $(pwd)"
          
          # Start Next.js server
          PORT=$PORT npm run start &
          APP_PID=$!
          
          # Cleanup function
          cleanup() {
            echo "Cleaning up server (PID: $APP_PID)..."
            kill -TERM $APP_PID 2>/dev/null || true
            sleep 2
            kill -KILL $APP_PID 2>/dev/null || true
            wait $APP_PID 2>/dev/null || true
          }
          trap cleanup EXIT
          
          # Wait for server
          echo "Waiting for server on http://localhost:$PORT..."
          npx wait-on --timeout 60000 http://localhost:$PORT
          
          # Build Lighthouse settings
          SETTINGS="--settings.emulatedFormFactor=$FORM_FACTOR"
          if [ -n "$VIEWPORT_WIDTH" ]; then
            SETTINGS="$SETTINGS --settings.screenEmulation.width=$VIEWPORT_WIDTH --settings.screenEmulation.height=$VIEWPORT_HEIGHT"
          fi
          
          # Run Lighthouse
          npx lhci collect \
            --url=http://localhost:$PORT \
            $SETTINGS \
            --settings.maxWaitForLoad=60000 \
            --settings.chromeFlags="--no-sandbox --disable-dev-shm-usage" \
            --no-upload
          
          cleanup
          trap - EXIT
          
          # Verify and copy reports
          echo "Checking for generated reports..."
          ls -la .lighthouseci/ || echo "No .lighthouseci directory found"
          
          # Create output directory and copy reports
          mkdir -p lighthouse-reports
          if [ -d .lighthouseci ]; then
            cp -r .lighthouseci/* lighthouse-reports/ 2>/dev/null || true
            echo "Copied reports to lighthouse-reports/"
            ls -la lighthouse-reports/
          fi
          
          JSON_COUNT=$(find lighthouse-reports -name "*.json" -type f 2>/dev/null | wc -l)
          if [ "$JSON_COUNT" -gt 0 ]; then
            echo "‚úì Lighthouse $DEVICE audit completed successfully! Found $JSON_COUNT JSON report(s)"
          else
            echo "‚ö† Warning: No JSON reports found for $DEVICE"
          fi

      - name: Debug - Check files before upload
        if: always()
        run: |
          echo "Current directory:"
          pwd
          echo "Checking lighthouse-reports directory:"
          ls -la lighthouse-reports/ || echo "Directory not found"
          echo "Finding JSON files:"
          find lighthouse-reports -name "*.json" -type f 2>/dev/null || echo "No JSON files found"

      - name: Upload Lighthouse report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-${{ matrix.device }}
          path: lighthouse-reports/
          retention-days: 7
          if-no-files-found: warn

  report:
    name: Generate Report
    runs-on: ubuntu-latest
    needs: [build, lighthouse]
    if: always() && needs.build.outputs.should-run-lighthouse == 'true'
    timeout-minutes: 5
    
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: lighthouse-results

      - name: Generate PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'üü¢';
              if (score >= 75) return 'üü°';
              return 'üî¥';
            };
            
            const processDevice = async (device) => {
              try {
                const dir = `lighthouse-results/lighthouse-${device}`;
                const allFiles = await fs.readdir(dir, { recursive: true });
                const jsonFile = allFiles.find(f => f.endsWith('.json') && f.includes('lhr-'));
                
                if (!jsonFile) {
                  console.log(`No JSON file found for ${device}. Files:`, allFiles);
                  return null;
                }
                
                const report = JSON.parse(await fs.readFile(path.join(dir, jsonFile), 'utf8'));
                const categories = report.categories;
                
                return {
                  performance: Math.round(categories.performance.score * 100),
                  accessibility: Math.round(categories.accessibility.score * 100),
                  bestPractices: Math.round(categories['best-practices'].score * 100),
                  seo: Math.round(categories.seo.score * 100)
                };
              } catch (error) {
                console.log(`No data for ${device}: ${error.message}`);
                return null;
              }
            };
            
            const [mobile, desktop, tablet] = await Promise.all([
              processDevice('mobile'),
              processDevice('desktop'),
              processDevice('tablet')
            ]);
            
            const formatRow = (device, scores) => {
              if (!scores) return `| ${device} | ‚ùå No data | - | - | - |`;
              return `| ${device} | ${getScoreEmoji(scores.performance)} ${scores.performance} | ${getScoreEmoji(scores.accessibility)} ${scores.accessibility} | ${getScoreEmoji(scores.bestPractices)} ${scores.bestPractices} | ${getScoreEmoji(scores.seo)} ${scores.seo} |`;
            };
            
            const comment = [
              '## ‚ö° Lighthouse Audit Results',
              '',
              '| Device | Performance | Accessibility | Best Practices | SEO |',
              '|--------|-------------|---------------|----------------|-----|',
              formatRow('üì± Mobile', mobile),
              formatRow('üñ•Ô∏è Desktop', desktop),
              formatRow('üì± Tablet', tablet),
              '',
              '**Legend:** üü¢ 90+ | üü° 75-89 | üî¥ <75',
              '',
              `[View detailed reports](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`
            ].join('\n');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Generate Actions Summary
        if: always()
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'üü¢';
              if (score >= 75) return 'üü°';
              return 'üî¥';
            };
            
            const processDevice = async (device) => {
              try {
                const dir = `lighthouse-results/lighthouse-${device}`;
                const allFiles = await fs.readdir(dir, { recursive: true });
                const jsonFile = allFiles.find(f => f.endsWith('.json') && f.includes('lhr-'));
                
                if (!jsonFile) {
                  console.log(`No JSON file found for ${device}. Files:`, allFiles);
                  return null;
                }
                
                const report = JSON.parse(await fs.readFile(path.join(dir, jsonFile), 'utf8'));
                const categories = report.categories;
                
                return {
                  performance: Math.round(categories.performance.score * 100),
                  accessibility: Math.round(categories.accessibility.score * 100),
                  bestPractices: Math.round(categories['best-practices'].score * 100),
                  seo: Math.round(categories.seo.score * 100)
                };
              } catch (error) {
                console.log(`No data for ${device}: ${error.message}`);
                return null;
              }
            };
            
            const [mobile, desktop, tablet] = await Promise.all([
              processDevice('mobile'),
              processDevice('desktop'),
              processDevice('tablet')
            ]);
            
            const formatRow = (device, scores) => {
              if (!scores) return `| ${device} | ‚ùå No data | - | - | - |`;
              return `| ${device} | ${getScoreEmoji(scores.performance)} ${scores.performance} | ${getScoreEmoji(scores.accessibility)} ${scores.accessibility} | ${getScoreEmoji(scores.bestPractices)} ${scores.bestPractices} | ${getScoreEmoji(scores.seo)} ${scores.seo} |`;
            };
            
            let summary = `# ‚ö° Lighthouse Audit Results\n\n`;
            summary += `> Branch: \`${process.env.GITHUB_REF_NAME}\` ‚Ä¢ Run: #${process.env.GITHUB_RUN_NUMBER}\n\n`;
            summary += `| Device | Performance | Accessibility | Best Practices | SEO |\n`;
            summary += `|--------|-------------|---------------|----------------|-----|\n`;
            summary += `${formatRow('üì± Mobile', mobile)}\n`;
            summary += `${formatRow('üñ•Ô∏è Desktop', desktop)}\n`;
            summary += `${formatRow('üì± Tablet', tablet)}\n\n`;
            summary += `**Legend:** üü¢ 90+ | üü° 75-89 | üî¥ <75\n\n`;
            summary += `---\n*Generated on ${new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' })} CET*`;
            
            await core.summary.addRaw(summary).write();

      - name: Prepare Discord notification
        if: always()
        id: prepare-discord
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const getScoreColor = (score) => {
              if (score >= 90) return 0x00ff00; // Green
              if (score >= 75) return 0xffff00; // Yellow
              return 0xff0000; // Red
            };
            
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'üü¢';
              if (score >= 75) return 'üü°';
              return 'üî¥';
            };
            
            const processDevice = async (device) => {
              try {
                const dir = `lighthouse-results/lighthouse-${device}`;
                const allFiles = await fs.readdir(dir, { recursive: true });
                const jsonFile = allFiles.find(f => f.endsWith('.json') && f.includes('lhr-'));
                
                if (!jsonFile) return null;
                
                const report = JSON.parse(await fs.readFile(path.join(dir, jsonFile), 'utf8'));
                const categories = report.categories;
                
                return {
                  performance: Math.round(categories.performance.score * 100),
                  accessibility: Math.round(categories.accessibility.score * 100),
                  bestPractices: Math.round(categories['best-practices'].score * 100),
                  seo: Math.round(categories.seo.score * 100)
                };
              } catch (error) {
                return null;
              }
            };
            
            const [mobile, desktop, tablet] = await Promise.all([
              processDevice('mobile'),
              processDevice('desktop'),
              processDevice('tablet')
            ]);
            
            // Calculate average performance score for embed color
            const scores = [mobile, desktop, tablet].filter(s => s !== null);
            const avgPerformance = scores.length > 0 
              ? Math.round(scores.reduce((sum, s) => sum + s.performance, 0) / scores.length)
              : 0;
            
            const formatField = (device, emoji, scores) => {
              if (!scores) {
                return {
                  name: `${emoji} ${device}`,
                  value: '‚ùå No data available',
                  inline: true
                };
              }
              return {
                name: `${emoji} ${device}`,
                value: [
                  `${getScoreEmoji(scores.performance)} **Performance:** ${scores.performance}`,
                  `${getScoreEmoji(scores.accessibility)} **Accessibility:** ${scores.accessibility}`,
                  `${getScoreEmoji(scores.bestPractices)} **Best Practices:** ${scores.bestPractices}`,
                  `${getScoreEmoji(scores.seo)} **SEO:** ${scores.seo}`
                ].join('\n'),
                inline: true
              };
            };
            
            const eventType = process.env.GITHUB_EVENT_NAME;
            const branch = process.env.GITHUB_REF_NAME;
            const runNumber = process.env.GITHUB_RUN_NUMBER;
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            const repoUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}`;
            
            let title = '‚ö° Lighthouse Audit Results';
            let description = `**Branch:** \`${branch}\`\n**Run:** #${runNumber}`;
            
            if (eventType === 'pull_request') {
              const prNumber = context.payload.pull_request?.number;
              const prUrl = context.payload.pull_request?.html_url;
              title = `‚ö° Lighthouse Audit - PR #${prNumber}`;
              description = `**PR:** [#${prNumber}](${prUrl})\n**Branch:** \`${branch}\``;
            } else if (eventType === 'push') {
              title = '‚ö° Lighthouse Audit - Push to Main';
            } else if (eventType === 'workflow_dispatch') {
              title = '‚ö° Lighthouse Audit - Manual Run';
            }
            
            const embed = {
              title,
              description,
              color: getScoreColor(avgPerformance),
              fields: [
                formatField('Mobile', 'üì±', mobile),
                formatField('Desktop', 'üñ•Ô∏è', desktop),
                formatField('Tablet', 'üì±', tablet),
                {
                  name: 'üìä Legend',
                  value: 'üü¢ Excellent (90+) ‚Ä¢ üü° Good (75-89) ‚Ä¢ üî¥ Needs Work (<75)',
                  inline: false
                },
                {
                  name: 'üîó Links',
                  value: `[View Full Report](${runUrl}) ‚Ä¢ [Repository](${repoUrl})`,
                  inline: false
                }
              ],
              timestamp: new Date().toISOString(),
              footer: {
                text: 'Lighthouse CI',
                icon_url: 'https://raw.githubusercontent.com/GoogleChrome/lighthouse/main/assets/lighthouse-logo.png'
              }
            };
            
            await fs.writeFile('discord-payload.json', JSON.stringify({ embeds: [embed] }));
            console.log('Discord payload prepared');

      - name: Send Discord notification
        if: always()
        run: |
          # Send the embed
          curl -H "Content-Type: application/json" \
            -d @discord-payload.json \
            https://discord.com/api/webhooks/1427189522764140565/pmtcfhnQiZ_ERvVGvZbdqYHp_pJrFxbIcDLC722-ucw7Z7UX2__Vue9GJpyeuzfMfpPy
          
          echo "Discord notification sent successfully"

      - name: Create individual device zip files
        if: always()
        run: |
          cd lighthouse-results
          
          # Create separate zip files for each device
          for device in mobile desktop tablet; do
            if [ -d "lighthouse-${device}" ]; then
              echo "Creating zip for ${device}..."
              cd "lighthouse-${device}"
              zip -r "../../lighthouse-${device}-report.zip" . -i "*.json" "*.html" 2>/dev/null || true
              cd ..
              
              if [ -f "../lighthouse-${device}-report.zip" ] && [ -s "../lighthouse-${device}-report.zip" ]; then
                echo "‚úì Created lighthouse-${device}-report.zip"
              else
                echo "‚ö† Warning: Failed to create zip for ${device}"
              fi
            else
              echo "‚ö† Warning: No reports found for ${device}"
            fi
          done
          
          cd ..
          echo "Listing created zip files:"
          ls -lh lighthouse-*-report.zip 2>/dev/null || echo "No zip files created"

      - name: Upload Mobile reports to Discord
        if: always()
        run: |
          if [ -f lighthouse-mobile-report.zip ] && [ -s lighthouse-mobile-report.zip ]; then
            echo "Uploading Mobile Lighthouse reports to Discord..."
            curl -F "file=@lighthouse-mobile-report.zip" \
              -F "content=üì± **Mobile Lighthouse Report** - Detailed analysis for mobile devices" \
              https://discord.com/api/webhooks/1427189522764140565/pmtcfhnQiZ_ERvVGvZbdqYHp_pJrFxbIcDLC722-ucw7Z7UX2__Vue9GJpyeuzfMfpPy
            echo "‚úì Mobile reports uploaded"
          else
            echo "‚ö† No mobile reports to upload"
          fi

      - name: Upload Desktop reports to Discord
        if: always()
        run: |
          if [ -f lighthouse-desktop-report.zip ] && [ -s lighthouse-desktop-report.zip ]; then
            echo "Uploading Desktop Lighthouse reports to Discord..."
            curl -F "file=@lighthouse-desktop-report.zip" \
              -F "content=üñ•Ô∏è **Desktop Lighthouse Report** - Detailed analysis for desktop devices" \
              https://discord.com/api/webhooks/1427189522764140565/pmtcfhnQiZ_ERvVGvZbdqYHp_pJrFxbIcDLC722-ucw7Z7UX2__Vue9GJpyeuzfMfpPy
            echo "‚úì Desktop reports uploaded"
          else
            echo "‚ö† No desktop reports to upload"
          fi

      - name: Upload Tablet reports to Discord
        if: always()
        run: |
          if [ -f lighthouse-tablet-report.zip ] && [ -s lighthouse-tablet-report.zip ]; then
            echo "Uploading Tablet Lighthouse reports to Discord..."
            curl -F "file=@lighthouse-tablet-report.zip" \
              -F "content=üì± **Tablet Lighthouse Report** - Detailed analysis for tablet devices" \
              https://discord.com/api/webhooks/1427189522764140565/pmtcfhnQiZ_ERvVGvZbdqYHp_pJrFxbIcDLC722-ucw7Z7UX2__Vue9GJpyeuzfMfpPy
            echo "‚úì Tablet reports uploaded"
          else
            echo "‚ö† No tablet reports to upload"
          fi