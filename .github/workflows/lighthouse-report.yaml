name: Lighthouse CI

on:
  push:
    branches: ["main"]
    paths-ignore:
      - '**/*.md'
      - '**/*.mdx'
  pull_request:
    paths-ignore:
      - '**/*.md'
      - '**/*.mdx'

# Set a timeout for the entire job (in minutes)
jobs:
  lighthouse:
    name: Lighthouse Audit
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Cache Node.js dependencies and build outputs
      - name: Cache Node.js modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            ~/.cache
            node_modules
            .next/cache
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json', '**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-

      # Setup Node.js with caching
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      # Install dependencies and tools
      - name: Install dependencies
        run: |
          # Install project dependencies
          if [ -f yarn.lock ]; then
            yarn install --frozen-lockfile --prefer-offline
          else
            npm ci --prefer-offline
          fi
          
          # Install Lighthouse CI and wait-on as dev dependencies
          npm install --save-dev @lhci/cli wait-on

      # Build the application
      - name: Build application
        run: npm run build

      # Run Lighthouse audits
      - name: Run Lighthouse audits
        id: lighthouse
        timeout-minutes: 12
        run: |
          # Create output directories
          mkdir -p .lighthouseci/mobile .lighthouseci/desktop
          
          # Function to kill all processes on a specific port
          kill_port_processes() {
            local port=$1
            echo "Cleaning up processes on port $port..."
            
            # Find and kill processes using the port
            lsof -ti:$port | xargs -r kill -9 2>/dev/null || true
            
            # Wait a moment for processes to terminate
            sleep 2
            
            # Double-check that port is free
            if lsof -i:$port >/dev/null 2>&1; then
              echo "Warning: Port $port still in use after cleanup"
              lsof -i:$port
            else
              echo "Port $port successfully freed"
            fi
          }
          
          # Function to run Lighthouse and handle errors
          run_lighthouse() {
            local form_factor=$1
            local port=$2
            local output_dir=".lighthouseci/$form_factor"
            local max_attempts=3
            local attempt=1
            local success=false
            
            echo "Starting Lighthouse $form_factor audit on port $port..."
            
            while [ $attempt -le $max_attempts ] && [ "$success" = false ]; do
              echo "Running Lighthouse $form_factor audit (attempt $attempt/$max_attempts)..."
              
              # Clean up any existing processes on the port first
              kill_port_processes $port
              
              # Start Next.js server in background with custom port
              echo "Starting Next.js server on port $port..."
              PORT=$port npm run start &
              APP_PID=$!
              
              # Function to cleanup this specific run
              cleanup() {
                echo "Cleaning up Lighthouse $form_factor test (PID: $APP_PID)..."
                
                # Kill the specific process
                if [ -n "$APP_PID" ] && kill -0 $APP_PID 2>/dev/null; then
                  echo "Stopping Next.js server (PID: $APP_PID)..."
                  kill -TERM $APP_PID 2>/dev/null || true
                  
                  # Wait for graceful shutdown
                  sleep 3
                  
                  # Force kill if still running
                  if kill -0 $APP_PID 2>/dev/null; then
                    echo "Force killing server (PID: $APP_PID)..."
                    kill -KILL $APP_PID 2>/dev/null || true
                  fi
                  
                  wait $APP_PID 2>/dev/null || true
                fi
                
                # Clean up any remaining processes on the port
                kill_port_processes $port
              }
              
              # Ensure cleanup happens on script exit or error
              trap cleanup EXIT
              
              # Wait for server to be ready with custom port
              echo "Waiting for server to be ready on http://localhost:$port..."
              if npx wait-on --timeout 90000 http://localhost:$port; then
                echo "Server is ready, starting Lighthouse audit..."
                
                # Run Lighthouse with custom port
                if npx lhci collect \
                  --url=http://localhost:$port \
                  --settings.emulatedFormFactor=$form_factor \
                  --settings.maxWaitForLoad=90000 \
                  --settings.chromeFlags="--no-sandbox --disable-dev-shm-usage" \
                  --no-upload; then
                  
                  # Move reports to appropriate directory
                  if ls .lighthouseci/lhr-*.json 1> /dev/null 2>&1; then
                    mv .lighthouseci/lhr-*.json "$output_dir/"
                    success=true
                    echo "Lighthouse $form_factor audit completed successfully"
                  else
                    echo "Warning: No Lighthouse reports were generated"
                  fi
                else
                  echo "Lighthouse $form_factor audit failed (attempt $attempt/$max_attempts)"
                fi
              else
                echo "Error: Application failed to start within timeout on port $port"
              fi
              
              # Cleanup and increment attempt counter
              cleanup
              trap - EXIT  # Remove the trap
              
              attempt=$((attempt + 1))
              
              # Small delay between retries
              if [ $attempt -le $max_attempts ] && [ "$success" = false ]; then
                echo "Retrying in 5 seconds..."
                sleep 5
              fi
            done
            
            if [ "$success" = false ]; then
              echo "Error: Failed to complete Lighthouse $form_factor audit after $max_attempts attempts"
              return 1
            fi
          }
          
          # Run audits for mobile and desktop on different ports to avoid conflicts
          run_lighthouse mobile 3001
          run_lighthouse desktop 3002
          
          # Verify reports were generated
          if [ -z "$(find .lighthouseci -name '*.json' -print -quit)" ]; then
            echo "Error: No Lighthouse reports were generated"
            exit 1
          fi
          
          echo "All Lighthouse audits completed successfully!"

      # Upload results as artifacts
      - name: Upload Lighthouse reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-reports
          path: |
            .lighthouseci/mobile
            .lighthouseci/desktop
          retention-days: 7
          if-no-files-found: warn

      # Optional: Add a comment to the PR with the results
      - name: Add PR comment with results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            
            try { // Read and process Lighthouse reports
              const processReport = async (reportPath) => {
                try {
                  const files = await fs.readdir(reportPath);
                  const jsonFiles = files.filter(file => file.endsWith('.json'));
                  
                  if (jsonFiles.length === 0) return null;
                  
                  const report = JSON.parse(await fs.readFile(`${reportPath}/${jsonFiles[0]}`, 'utf8'));
                  const { categories } = report;
                  
                  return Object.entries(categories).map(([key, value]) => ({
                    name: value.title,
                    score: Math.round(value.score * 100)
                  }));
                } catch (error) {
                  core.warning(`Failed to process report at ${reportPath}: ${error.message}`);
                  return null;
                }
              };
              
              const mobileScores = await processReport('.lighthouseci/mobile');
              const desktopScores = await processReport('.lighthouseci/desktop');
              
              if (!mobileScores && !desktopScores) {
                core.warning('No valid Lighthouse reports found');
                return;
              }
              
              const formatScores = (scores) => {
                if (!scores) return '‚ùå No data';
                return scores.map(s => `${s.name}: ${s.score}%`).join(' | ');
              };
              
              // Build the comment using string concatenation to avoid YAML parsing issues
              const comment = '## ‚ö° Lighthouse Audit Results\n\n### üì± Mobile\n' + 
                formatScores(mobileScores) + 
                '\n\n### üñ•Ô∏è Desktop\n' + 
                formatScores(desktopScores) + 
                '\n\n[View full report](' + 
                process.env.GITHUB_SERVER_URL + '/' + 
                process.env.GITHUB_REPOSITORY + 
                '/actions/runs/' + 
                process.env.GITHUB_RUN_ID + 
                ')';
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              
              console.log('Successfully posted Lighthouse results to PR');
            } catch (error) {
              core.warning(`Failed to create PR comment: ${error.message}`);
            }