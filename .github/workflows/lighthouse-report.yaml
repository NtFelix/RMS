name: Lighthouse CI

on:
  pull_request:
    branches: [main, develop]
    types: [opened, reopened, synchronize]
  push:
    branches: [main]
  workflow_dispatch:  # Allows manual triggering from the Actions tab

jobs:
  build:
    name: Build Application
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      build-cache-key: ${{ steps.build-cache-key.outputs.cache-key }}
      should-run-lighthouse: ${{ steps.check-trigger.outputs.should-run }}
    
    steps:
      - name: Check if Lighthouse should run
        id: check-trigger
        run: |
          # Run Lighthouse on:
          # 1. PR opened/reopened (not on every push to PR)
          # 2. Push to main (merge)
          # 3. Manual workflow dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "Reason: Manual trigger"
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "Reason: Push to main"
          elif [[ "${{ github.event_name }}" == "pull_request" && ("${{ github.event.action }}" == "opened" || "${{ github.event.action }}" == "reopened") ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "Reason: PR opened/reopened"
          else
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "Reason: Regular PR update - skipping Lighthouse"
          fi
    
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate build cache key
        id: build-cache-key
        run: |
          # Create a hash of all files that affect the build
          BUILD_HASH=$(find app components lib hooks types utils public -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" -o -name "*.css" -o -name "*.json" \) -exec sha256sum {} \; 2>/dev/null | sort | sha256sum | cut -d' ' -f1 || echo "no-files")
          PACKAGE_HASH="${{ hashFiles('**/package-lock.json', '**/package.json', 'next.config.js', 'tsconfig.json', 'tailwind.config.ts') }}"
          CACHE_KEY="build-${BUILD_HASH}-${PACKAGE_HASH}"
          echo "cache-key=${CACHE_KEY}" >> $GITHUB_OUTPUT
          echo "Build cache key: ${CACHE_KEY}"

      - name: Restore build cache
        id: restore-build-cache
        uses: actions/cache/restore@v4
        with:
          path: .next
          key: ${{ steps.build-cache-key.outputs.cache-key }}
          restore-keys: |
            build-

      - name: Cache node_modules
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install dependencies
        if: steps.restore-build-cache.outputs.cache-hit != 'true' && steps.cache-node-modules.outputs.cache-hit != 'true'
        run: npm ci --prefer-offline

      - name: Build application
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        run: npm run build

      - name: Save build cache
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: .next
          key: ${{ steps.build-cache-key.outputs.cache-key }}

      - name: Build status
        run: |
          if [ "${{ steps.restore-build-cache.outputs.cache-hit }}" == "true" ]; then
            echo "âœ“ Build restored from cache"
          else
            echo "âœ“ Build completed and cached"
          fi

  lighthouse:
    name: Lighthouse Audit (${{ matrix.device }})
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.should-run-lighthouse == 'true'
    timeout-minutes: 10
    
    strategy:
      fail-fast: false
      matrix:
        device: [mobile, desktop, tablet]
        include:
          - device: mobile
            form-factor: mobile
            port: 3001
          - device: desktop
            form-factor: desktop
            port: 3002
          - device: tablet
            form-factor: mobile
            port: 3003
            viewport-width: 768
            viewport-height: 1024
    
    permissions:
      contents: read

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Restore build cache
        uses: actions/cache/restore@v4
        with:
          path: .next
          key: ${{ needs.build.outputs.build-cache-key }}
          restore-keys: |
            build-
          fail-on-cache-miss: true

      - name: Install Lighthouse CI tools
        run: npm install --no-save @lhci/cli wait-on

      - name: Run Lighthouse audit
        id: lighthouse
        timeout-minutes: 8
        run: |
          DEVICE="${{ matrix.device }}"
          FORM_FACTOR="${{ matrix.form-factor }}"
          PORT="${{ matrix.port }}"
          VIEWPORT_WIDTH="${{ matrix.viewport-width }}"
          VIEWPORT_HEIGHT="${{ matrix.viewport-height }}"
          
          echo "Running Lighthouse audit for $DEVICE..."
          echo "Working directory: $(pwd)"
          
          # Start Next.js server
          PORT=$PORT npm run start &
          APP_PID=$!
          
          # Cleanup function
          cleanup() {
            echo "Cleaning up server (PID: $APP_PID)..."
            kill -TERM $APP_PID 2>/dev/null || true
            sleep 2
            kill -KILL $APP_PID 2>/dev/null || true
            wait $APP_PID 2>/dev/null || true
          }
          trap cleanup EXIT
          
          # Wait for server
          echo "Waiting for server on http://localhost:$PORT..."
          npx wait-on --timeout 60000 http://localhost:$PORT
          
          # Build Lighthouse settings
          SETTINGS="--settings.emulatedFormFactor=$FORM_FACTOR"
          if [ -n "$VIEWPORT_WIDTH" ]; then
            SETTINGS="$SETTINGS --settings.screenEmulation.width=$VIEWPORT_WIDTH --settings.screenEmulation.height=$VIEWPORT_HEIGHT"
          fi
          
          # Run Lighthouse
          npx lhci collect \
            --url=http://localhost:$PORT \
            $SETTINGS \
            --settings.maxWaitForLoad=60000 \
            --settings.chromeFlags="--no-sandbox --disable-dev-shm-usage" \
            --no-upload
          
          cleanup
          trap - EXIT
          
          # Verify and copy reports
          echo "Checking for generated reports..."
          ls -la .lighthouseci/ || echo "No .lighthouseci directory found"
          
          # Create output directory and copy reports
          mkdir -p lighthouse-reports
          if [ -d .lighthouseci ]; then
            cp -r .lighthouseci/* lighthouse-reports/ 2>/dev/null || true
            echo "Copied reports to lighthouse-reports/"
            ls -la lighthouse-reports/
          fi
          
          JSON_COUNT=$(find lighthouse-reports -name "*.json" -type f 2>/dev/null | wc -l)
          if [ "$JSON_COUNT" -gt 0 ]; then
            echo "âœ“ Lighthouse $DEVICE audit completed successfully! Found $JSON_COUNT JSON report(s)"
          else
            echo "âš  Warning: No JSON reports found for $DEVICE"
          fi

      - name: Debug - Check files before upload
        if: always()
        run: |
          echo "Current directory:"
          pwd
          echo "Checking lighthouse-reports directory:"
          ls -la lighthouse-reports/ || echo "Directory not found"
          echo "Finding JSON files:"
          find lighthouse-reports -name "*.json" -type f 2>/dev/null || echo "No JSON files found"

      - name: Upload Lighthouse report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-${{ matrix.device }}
          path: lighthouse-reports/
          retention-days: 7
          if-no-files-found: warn

  report:
    name: Generate Report
    runs-on: ubuntu-latest
    needs: [build, lighthouse]
    if: always() && needs.build.outputs.should-run-lighthouse == 'true'
    timeout-minutes: 5
    
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v5
        with:
          path: lighthouse-results

      - name: Generate PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'ğŸŸ¢';
              if (score >= 75) return 'ğŸŸ¡';
              return 'ğŸ”´';
            };
            
            const processDevice = async (device) => {
              try {
                const dir = `lighthouse-results/lighthouse-${device}`;
                const allFiles = await fs.readdir(dir, { recursive: true });
                const jsonFile = allFiles.find(f => f.endsWith('.json') && f.includes('lhr-'));
                
                if (!jsonFile) {
                  console.log(`No JSON file found for ${device}. Files:`, allFiles);
                  return null;
                }
                
                const report = JSON.parse(await fs.readFile(path.join(dir, jsonFile), 'utf8'));
                const categories = report.categories;
                
                return {
                  performance: Math.round(categories.performance.score * 100),
                  accessibility: Math.round(categories.accessibility.score * 100),
                  bestPractices: Math.round(categories['best-practices'].score * 100),
                  seo: Math.round(categories.seo.score * 100)
                };
              } catch (error) {
                console.log(`No data for ${device}: ${error.message}`);
                return null;
              }
            };
            
            const [mobile, desktop, tablet] = await Promise.all([
              processDevice('mobile'),
              processDevice('desktop'),
              processDevice('tablet')
            ]);
            
            const formatRow = (device, scores) => {
              if (!scores) return `| ${device} | âŒ No data | - | - | - |`;
              return `| ${device} | ${getScoreEmoji(scores.performance)} ${scores.performance} | ${getScoreEmoji(scores.accessibility)} ${scores.accessibility} | ${getScoreEmoji(scores.bestPractices)} ${scores.bestPractices} | ${getScoreEmoji(scores.seo)} ${scores.seo} |`;
            };
            
            const comment = [
              '## âš¡ Lighthouse Audit Results',
              '',
              '| Device | Performance | Accessibility | Best Practices | SEO |',
              '|--------|-------------|---------------|----------------|-----|',
              formatRow('ğŸ“± Mobile', mobile),
              formatRow('ğŸ–¥ï¸ Desktop', desktop),
              formatRow('ğŸ“± Tablet', tablet),
              '',
              '**Legend:** ğŸŸ¢ 90+ | ğŸŸ¡ 75-89 | ğŸ”´ <75',
              '',
              `[View detailed reports](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`
            ].join('\n');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Generate Actions Summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'ğŸŸ¢';
              if (score >= 75) return 'ğŸŸ¡';
              return 'ğŸ”´';
            };
            
            const processDevice = async (device) => {
              try {
                const dir = `lighthouse-results/lighthouse-${device}`;
                const allFiles = await fs.readdir(dir, { recursive: true });
                const jsonFile = allFiles.find(f => f.endsWith('.json') && f.includes('lhr-'));
                
                if (!jsonFile) {
                  console.log(`No JSON file found for ${device}. Files:`, allFiles);
                  return null;
                }
                
                const report = JSON.parse(await fs.readFile(path.join(dir, jsonFile), 'utf8'));
                const categories = report.categories;
                
                return {
                  performance: Math.round(categories.performance.score * 100),
                  accessibility: Math.round(categories.accessibility.score * 100),
                  bestPractices: Math.round(categories['best-practices'].score * 100),
                  seo: Math.round(categories.seo.score * 100)
                };
              } catch (error) {
                console.log(`No data for ${device}: ${error.message}`);
                return null;
              }
            };
            
            const [mobile, desktop, tablet] = await Promise.all([
              processDevice('mobile'),
              processDevice('desktop'),
              processDevice('tablet')
            ]);
            
            const formatRow = (device, scores) => {
              if (!scores) return `| ${device} | âŒ No data | - | - | - |`;
              return `| ${device} | ${getScoreEmoji(scores.performance)} ${scores.performance} | ${getScoreEmoji(scores.accessibility)} ${scores.accessibility} | ${getScoreEmoji(scores.bestPractices)} ${scores.bestPractices} | ${getScoreEmoji(scores.seo)} ${scores.seo} |`;
            };
            
            let summary = `# âš¡ Lighthouse Audit Results\n\n`;
            summary += `> Branch: \`${process.env.GITHUB_REF_NAME}\` â€¢ Run: #${process.env.GITHUB_RUN_NUMBER}\n\n`;
            summary += `| Device | Performance | Accessibility | Best Practices | SEO |\n`;
            summary += `|--------|-------------|---------------|----------------|-----|\n`;
            summary += `${formatRow('ğŸ“± Mobile', mobile)}\n`;
            summary += `${formatRow('ğŸ–¥ï¸ Desktop', desktop)}\n`;
            summary += `${formatRow('ğŸ“± Tablet', tablet)}\n\n`;
            summary += `**Legend:** ğŸŸ¢ 90+ | ğŸŸ¡ 75-89 | ğŸ”´ <75\n\n`;
            summary += `---\n*Generated on ${new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' })} CET*`;
            
            await core.summary.addRaw(summary).write();