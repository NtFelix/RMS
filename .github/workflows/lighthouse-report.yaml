name: Lighthouse CI

on:
  pull_request:
    branches: [main, develop]
    types: [opened, reopened, synchronize, closed]
  push:
    branches: [main]
  workflow_dispatch:  # Allows manual triggering from the Actions tab

jobs:
  # Lightweight job to determine if lighthouse should run and which devices to test
  # This allows build and prepare-lhci to run truly in parallel
  determine-platforms:
    name: Determine Lighthouse Platforms
    runs-on: ubuntu-latest
    timeout-minutes: 1
    outputs:
      should-run-lighthouse: ${{ steps.check.outputs.should-run }}
      device-matrix: ${{ steps.check.outputs.device-matrix }}
    
    steps:
      - name: Determine audit scope
        id: check
        run: |
          # Determine which devices to audit and whether to run
          # Full audit (all devices): PR merged/closed, push to main, manual dispatch, PR opened/reopened
          # Desktop only: PR synchronize (regular updates)
          # Skip: Other events
          
          FULL_MATRIX='["mobile", "desktop", "tablet"]'
          DESKTOP_ONLY='["desktop"]'
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "device-matrix=$FULL_MATRIX" >> $GITHUB_OUTPUT
            echo "Reason: Manual trigger - running all devices"
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "device-matrix=$FULL_MATRIX" >> $GITHUB_OUTPUT
            echo "Reason: Push to main - running all devices"
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "closed" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "device-matrix=$FULL_MATRIX" >> $GITHUB_OUTPUT
            echo "Reason: PR merged - running all devices"
          elif [[ "${{ github.event_name }}" == "pull_request" && ("${{ github.event.action }}" == "opened" || "${{ github.event.action }}" == "reopened") ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "device-matrix=$FULL_MATRIX" >> $GITHUB_OUTPUT
            echo "Reason: PR opened/reopened - running all devices"
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "synchronize" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "device-matrix=$DESKTOP_ONLY" >> $GITHUB_OUTPUT
            echo "Reason: PR synchronize - running desktop only for speed"
          else
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "device-matrix=$DESKTOP_ONLY" >> $GITHUB_OUTPUT
            echo "Reason: Unhandled event - skipping Lighthouse"
          fi

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: determine-platforms
    if: needs.determine-platforms.outputs.should-run-lighthouse == 'true'
    timeout-minutes: 10
    outputs:
      build-cache-key: ${{ steps.build-cache-key.outputs.cache-key }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Generate build cache key
        id: build-cache-key
        run: |
          # Create a hash of all files that affect the build
          BUILD_HASH=$(find app components lib hooks types utils public -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" -o -name "*.css" -o -name "*.json" \) -exec sha256sum {} \; 2>/dev/null | sort | sha256sum | cut -d' ' -f1 || echo "no-files")
          PACKAGE_HASH="${{ hashFiles('**/package-lock.json', '**/package.json', 'next.config.js', 'tsconfig.json', 'tailwind.config.ts') }}"
          CACHE_KEY="build-${BUILD_HASH}-${PACKAGE_HASH}"
          echo "cache-key=${CACHE_KEY}" >> $GITHUB_OUTPUT
          echo "Build cache key: ${CACHE_KEY}"

      - name: Restore build cache
        id: restore-build-cache
        uses: actions/cache/restore@v4
        with:
          path: .next
          key: ${{ steps.build-cache-key.outputs.cache-key }}
          restore-keys: |
            build-

      - name: Cache node_modules
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install dependencies
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        run: |
          # Only run npm ci if node_modules doesn't exist or is incomplete
          if [ ! -d "node_modules" ] || [ ! -f "node_modules/.package-lock.json" ]; then
            echo "Installing dependencies..."
            npm ci --prefer-offline
          else
            echo "‚úì node_modules exists and appears complete - skipping npm ci"
          fi

      - name: Build application
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        run: npm run build

      - name: Save build cache
        if: steps.restore-build-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: .next
          key: ${{ steps.build-cache-key.outputs.cache-key }}

      - name: Build status
        run: |
          if [ "${{ steps.restore-build-cache.outputs.cache-hit }}" == "true" ]; then
            echo "‚úì Build restored from cache"
          else
            echo "‚úì Build completed and cached"
          fi

  # Prepare LHCI tools in parallel with build for faster execution
  prepare-lhci:
    name: Prepare LHCI Tools
    runs-on: ubuntu-latest
    needs: determine-platforms  # Runs truly in parallel with build
    if: needs.determine-platforms.outputs.should-run-lighthouse == 'true'
    timeout-minutes: 3
    
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Restore LHCI tools cache
        id: lhci-cache
        uses: actions/cache@v4
        with:
          path: |
            lhci-tools/node_modules
            lhci-tools/package.json
            lhci-tools/package-lock.json
          key: lhci-tools-${{ runner.os }}-0.12.x
          
      - name: Create package.json and install LHCI tools
        if: steps.lhci-cache.outputs.cache-hit != 'true'
        run: |
          mkdir -p lhci-tools
          cd lhci-tools
          echo '{"name":"lhci-tools","private":true}' > package.json
          npm install @lhci/cli@0.12.x wait-on
          echo "‚úì LHCI tools installed and cached"

  lighthouse:
    name: Lighthouse Audit (${{ matrix.device }})
    runs-on: ubuntu-latest
    needs: [determine-platforms, build, prepare-lhci]
    if: needs.determine-platforms.outputs.should-run-lighthouse == 'true'
    timeout-minutes: 10
    
    strategy:
      fail-fast: false
      matrix:
        device: ${{ fromJson(needs.determine-platforms.outputs.device-matrix) }}
        include:
          - device: mobile
            form-factor: mobile
            port: 3001
          - device: desktop
            form-factor: desktop
            port: 3002
          - device: tablet
            form-factor: mobile
            port: 3003
            viewport-width: 768
            viewport-height: 1024
    
    permissions:
      contents: read

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Restore build cache
        uses: actions/cache/restore@v4
        with:
          path: .next
          key: ${{ needs.build.outputs.build-cache-key }}
          restore-keys: |
            build-
          fail-on-cache-miss: true

      - name: Install dependencies (if not cached)
        run: |
          # Only run npm ci if node_modules doesn't exist or is incomplete
          if [ ! -d "node_modules" ] || [ ! -f "node_modules/.package-lock.json" ]; then
            echo "Installing dependencies..."
            npm ci --prefer-offline
          else
            echo "‚úì node_modules exists and appears complete - skipping npm ci"
          fi

      - name: Restore LHCI tools cache
        uses: actions/cache@v4
        with:
          path: |
            lhci-tools/node_modules
            lhci-tools/package.json
            lhci-tools/package-lock.json
          key: lhci-tools-${{ runner.os }}-0.12.x
          fail-on-cache-miss: true

      - name: Verify LHCI tools
        run: |
          echo "Verifying LHCI tools..."
          npx --prefix lhci-tools lhci --version
          npx --prefix lhci-tools wait-on --version
          echo "‚úì LHCI tools verified"

      - name: Run Lighthouse audit
        id: lighthouse
        timeout-minutes: 8
        run: |
          DEVICE="${{ matrix.device }}"
          FORM_FACTOR="${{ matrix.form-factor }}"
          PORT="${{ matrix.port }}"
          VIEWPORT_WIDTH="${{ matrix.viewport-width }}"
          VIEWPORT_HEIGHT="${{ matrix.viewport-height }}"
          
          echo "Running Lighthouse audit for $DEVICE..."
          echo "Working directory: $(pwd)"
          
          # Start Next.js server
          PORT=$PORT npm run start &
          APP_PID=$!
          
          # Cleanup function
          cleanup() {
            echo "Cleaning up server (PID: $APP_PID)..."
            kill -TERM $APP_PID 2>/dev/null || true
            sleep 2
            kill -KILL $APP_PID 2>/dev/null || true
            wait $APP_PID 2>/dev/null || true
          }
          trap cleanup EXIT
          
          # Wait for server using cached wait-on
          echo "Waiting for server on http://localhost:$PORT..."
          npx --prefix lhci-tools wait-on --timeout 60000 http://localhost:$PORT
          
          # Build Lighthouse settings
          SETTINGS="--settings.emulatedFormFactor=$FORM_FACTOR"
          if [ -n "$VIEWPORT_WIDTH" ]; then
            SETTINGS="$SETTINGS --settings.screenEmulation.width=$VIEWPORT_WIDTH --settings.screenEmulation.height=$VIEWPORT_HEIGHT"
          fi
          
          # Run Lighthouse (single run for speed) using cached lhci
          npx --prefix lhci-tools lhci collect \
            --url=http://localhost:$PORT \
            --numberOfRuns=1 \
            $SETTINGS \
            --settings.maxWaitForLoad=60000 \
            --settings.chromeFlags="--no-sandbox --disable-dev-shm-usage" \
            --no-upload
          
          cleanup
          trap - EXIT
          
          # Verify and copy reports
          echo "Checking for generated reports..."
          ls -la .lighthouseci/ || echo "No .lighthouseci directory found"
          
          # Create output directory and copy reports
          mkdir -p lighthouse-reports
          if [ -d .lighthouseci ]; then
            cp -r .lighthouseci/* lighthouse-reports/ 2>/dev/null || true
            echo "Copied reports to lighthouse-reports/"
            ls -la lighthouse-reports/
          fi
          
          JSON_COUNT=$(find lighthouse-reports -name "*.json" -type f 2>/dev/null | wc -l)
          if [ "$JSON_COUNT" -gt 0 ]; then
            echo "‚úì Lighthouse $DEVICE audit completed successfully! Found $JSON_COUNT JSON report(s)"
          else
            echo "‚ö† Warning: No JSON reports found for $DEVICE"
          fi

      - name: Debug - Check files before upload
        if: failure()
        run: |
          echo "Current directory:"
          pwd
          echo "Checking lighthouse-reports directory:"
          ls -la lighthouse-reports/ || echo "Directory not found"
          echo "Finding JSON files:"
          find lighthouse-reports -name "*.json" -type f 2>/dev/null || echo "No JSON files found"

      - name: Upload Lighthouse report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-${{ matrix.device }}
          path: lighthouse-reports/
          retention-days: 7
          if-no-files-found: warn

  report:
    name: Generate Report
    runs-on: ubuntu-latest
    needs: [determine-platforms, build, lighthouse]
    if: always() && needs.determine-platforms.outputs.should-run-lighthouse == 'true'
    timeout-minutes: 5
    
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: lighthouse-results

      - name: Generate PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'üü¢';
              if (score >= 75) return 'üü°';
              return 'üî¥';
            };
            
            const processDevice = async (device) => {
              try {
                const dir = `lighthouse-results/lighthouse-${device}`;
                const allFiles = await fs.readdir(dir, { recursive: true });
                const jsonFile = allFiles.find(f => f.endsWith('.json') && f.includes('lhr-'));
                
                if (!jsonFile) {
                  console.log(`No JSON file found for ${device}. Files:`, allFiles);
                  return null;
                }
                
                const report = JSON.parse(await fs.readFile(path.join(dir, jsonFile), 'utf8'));
                const categories = report.categories;
                
                return {
                  performance: Math.round(categories.performance.score * 100),
                  accessibility: Math.round(categories.accessibility.score * 100),
                  bestPractices: Math.round(categories['best-practices'].score * 100),
                  seo: Math.round(categories.seo.score * 100)
                };
              } catch (error) {
                console.log(`No data for ${device}: ${error.message}`);
                return null;
              }
            };
            
            const [mobile, desktop, tablet] = await Promise.all([
              processDevice('mobile'),
              processDevice('desktop'),
              processDevice('tablet')
            ]);
            
            const formatRow = (device, scores) => {
              if (!scores) return `| ${device} | ‚ùå No data | - | - | - |`;
              return `| ${device} | ${getScoreEmoji(scores.performance)} ${scores.performance} | ${getScoreEmoji(scores.accessibility)} ${scores.accessibility} | ${getScoreEmoji(scores.bestPractices)} ${scores.bestPractices} | ${getScoreEmoji(scores.seo)} ${scores.seo} |`;
            };
            
            const comment = [
              '## ‚ö° Lighthouse Audit Results',
              '',
              '| Device | Performance | Accessibility | Best Practices | SEO |',
              '|--------|-------------|---------------|----------------|-----|',
              formatRow('üì± Mobile', mobile),
              formatRow('üñ•Ô∏è Desktop', desktop),
              formatRow('üì± Tablet', tablet),
              '',
              '**Legend:** üü¢ 90+ | üü° 75-89 | üî¥ <75',
              '',
              `[View detailed reports](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`
            ].join('\n');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Generate Actions Summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'üü¢';
              if (score >= 75) return 'üü°';
              return 'üî¥';
            };
            
            const processDevice = async (device) => {
              try {
                const dir = `lighthouse-results/lighthouse-${device}`;
                const allFiles = await fs.readdir(dir, { recursive: true });
                const jsonFile = allFiles.find(f => f.endsWith('.json') && f.includes('lhr-'));
                
                if (!jsonFile) {
                  console.log(`No JSON file found for ${device}. Files:`, allFiles);
                  return null;
                }
                
                const report = JSON.parse(await fs.readFile(path.join(dir, jsonFile), 'utf8'));
                const categories = report.categories;
                
                return {
                  performance: Math.round(categories.performance.score * 100),
                  accessibility: Math.round(categories.accessibility.score * 100),
                  bestPractices: Math.round(categories['best-practices'].score * 100),
                  seo: Math.round(categories.seo.score * 100)
                };
              } catch (error) {
                console.log(`No data for ${device}: ${error.message}`);
                return null;
              }
            };
            
            const [mobile, desktop, tablet] = await Promise.all([
              processDevice('mobile'),
              processDevice('desktop'),
              processDevice('tablet')
            ]);
            
            const formatRow = (device, scores) => {
              if (!scores) return `| ${device} | ‚ùå No data | - | - | - |`;
              return `| ${device} | ${getScoreEmoji(scores.performance)} ${scores.performance} | ${getScoreEmoji(scores.accessibility)} ${scores.accessibility} | ${getScoreEmoji(scores.bestPractices)} ${scores.bestPractices} | ${getScoreEmoji(scores.seo)} ${scores.seo} |`;
            };
            
            let summary = `# ‚ö° Lighthouse Audit Results\n\n`;
            summary += `> Branch: \`${process.env.GITHUB_REF_NAME}\` ‚Ä¢ Run: #${process.env.GITHUB_RUN_NUMBER}\n\n`;
            summary += `| Device | Performance | Accessibility | Best Practices | SEO |\n`;
            summary += `|--------|-------------|---------------|----------------|-----|\n`;
            summary += `${formatRow('üì± Mobile', mobile)}\n`;
            summary += `${formatRow('üñ•Ô∏è Desktop', desktop)}\n`;
            summary += `${formatRow('üì± Tablet', tablet)}\n\n`;
            summary += `**Legend:** üü¢ 90+ | üü° 75-89 | üî¥ <75\n\n`;
            summary += `---\n*Generated on ${new Date().toLocaleString('de-DE', { timeZone: 'Europe/Berlin' })} CET*`;
            
            await core.summary.addRaw(summary).write();

      - name: Prepare Discord notification
        if: always()
        id: prepare-discord
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            const getScoreColor = (score) => {
              if (score >= 90) return 0x00ff00; // Green
              if (score >= 75) return 0xffff00; // Yellow
              return 0xff0000; // Red
            };
            
            const getScoreEmoji = (score) => {
              if (score >= 90) return 'üü¢';
              if (score >= 75) return 'üü°';
              return 'üî¥';
            };
            
            const processDevice = async (device) => {
              try {
                const dir = `lighthouse-results/lighthouse-${device}`;
                const allFiles = await fs.readdir(dir, { recursive: true });
                const jsonFile = allFiles.find(f => f.endsWith('.json') && f.includes('lhr-'));
                
                if (!jsonFile) return null;
                
                const report = JSON.parse(await fs.readFile(path.join(dir, jsonFile), 'utf8'));
                const categories = report.categories;
                
                return {
                  performance: Math.round(categories.performance.score * 100),
                  accessibility: Math.round(categories.accessibility.score * 100),
                  bestPractices: Math.round(categories['best-practices'].score * 100),
                  seo: Math.round(categories.seo.score * 100)
                };
              } catch (error) {
                return null;
              }
            };
            
            const [mobile, desktop, tablet] = await Promise.all([
              processDevice('mobile'),
              processDevice('desktop'),
              processDevice('tablet')
            ]);
            
            // Calculate average performance score for embed color
            const scores = [mobile, desktop, tablet].filter(s => s !== null);
            const avgPerformance = scores.length > 0 
              ? Math.round(scores.reduce((sum, s) => sum + s.performance, 0) / scores.length)
              : 0;
            
            const formatField = (device, emoji, scores) => {
              if (!scores) {
                return {
                  name: `${emoji} ${device}`,
                  value: '‚ùå No data available',
                  inline: true
                };
              }
              return {
                name: `${emoji} ${device}`,
                value: [
                  `${getScoreEmoji(scores.performance)} **Performance:** ${scores.performance}`,
                  `${getScoreEmoji(scores.accessibility)} **Accessibility:** ${scores.accessibility}`,
                  `${getScoreEmoji(scores.bestPractices)} **Best Practices:** ${scores.bestPractices}`,
                  `${getScoreEmoji(scores.seo)} **SEO:** ${scores.seo}`
                ].join('\n'),
                inline: true
              };
            };
            
            const eventType = process.env.GITHUB_EVENT_NAME;
            const branch = process.env.GITHUB_REF_NAME;
            const runNumber = process.env.GITHUB_RUN_NUMBER;
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            const repoUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}`;
            
            let title = '‚ö° Lighthouse Audit Results';
            let description = `**Branch:** \`${branch}\`\n**Run:** #${runNumber}`;
            
            if (eventType === 'pull_request') {
              const prNumber = context.payload.pull_request?.number;
              const prUrl = context.payload.pull_request?.html_url;
              title = `‚ö° Lighthouse Audit - PR #${prNumber}`;
              description = `**PR:** [#${prNumber}](${prUrl})\n**Branch:** \`${branch}\``;
            } else if (eventType === 'push') {
              title = '‚ö° Lighthouse Audit - Push to Main';
            } else if (eventType === 'workflow_dispatch') {
              title = '‚ö° Lighthouse Audit - Manual Run';
            }
            
            const embed = {
              title,
              description,
              color: getScoreColor(avgPerformance),
              fields: [
                formatField('Mobile', 'üì±', mobile),
                formatField('Desktop', 'üñ•Ô∏è', desktop),
                formatField('Tablet', 'üì±', tablet),
                {
                  name: 'üìä Legend',
                  value: 'üü¢ Excellent (90+) ‚Ä¢ üü° Good (75-89) ‚Ä¢ üî¥ Needs Work (<75)',
                  inline: false
                },
                {
                  name: 'üîó Links',
                  value: `[View Full Report](${runUrl}) ‚Ä¢ [Repository](${repoUrl})`,
                  inline: false
                }
              ],
              timestamp: new Date().toISOString(),
              footer: {
                text: 'Lighthouse CI',
                icon_url: 'https://raw.githubusercontent.com/GoogleChrome/lighthouse/main/assets/lighthouse-logo.png'
              }
            };
            
            await fs.writeFile('discord-payload.json', JSON.stringify({ embeds: [embed] }));
            console.log('Discord payload prepared');

      - name: Create device zip files and send to Discord
        if: always()
        run: |
          WEBHOOK_URL="https://discord.com/api/webhooks/1427189522764140565/pmtcfhnQiZ_ERvVGvZbdqYHp_pJrFxbIcDLC722-ucw7Z7UX2__Vue9GJpyeuzfMfpPy"
          
          # Create zip files for each available device
          echo "Creating zip files for available device reports..."
          
          cd lighthouse-results
          for device in mobile desktop tablet; do
            if [ -d "lighthouse-${device}" ]; then
              echo "Creating zip for ${device}..."
              cd "lighthouse-${device}"
              zip -r "../../lighthouse-${device}-report.zip" . -i "*.json" "*.html" 2>/dev/null || true
              cd ..
              
              if [ -f "../lighthouse-${device}-report.zip" ] && [ -s "../lighthouse-${device}-report.zip" ]; then
                echo "‚úì Created lighthouse-${device}-report.zip"
              else
                echo "‚ö† Warning: Failed to create zip for ${device}"
              fi
            else
              echo "‚Ñπ No reports found for ${device} (may not have been audited)"
            fi
          done
          cd ..
          
          echo ""
          echo "Available zip files:"
          ls -lh lighthouse-*-report.zip 2>/dev/null || echo "No zip files created"
          
          # Build the curl command dynamically based on available files
          # Discord webhooks support up to 10 files per message
          echo ""
          echo "Sending Discord notification with embed and attachments..."
          
          # Start building curl command with the payload_json for the embed
          CURL_CMD="curl -s"
          FILE_COUNT=0
          
          # Add each available zip file
          if [ -f lighthouse-mobile-report.zip ] && [ -s lighthouse-mobile-report.zip ]; then
            CURL_CMD="$CURL_CMD -F 'files[$FILE_COUNT]=@lighthouse-mobile-report.zip;filename=lighthouse-mobile-report.zip'"
            FILE_COUNT=$((FILE_COUNT + 1))
            echo "  üì± Adding mobile report"
          fi
          
          if [ -f lighthouse-desktop-report.zip ] && [ -s lighthouse-desktop-report.zip ]; then
            CURL_CMD="$CURL_CMD -F 'files[$FILE_COUNT]=@lighthouse-desktop-report.zip;filename=lighthouse-desktop-report.zip'"
            FILE_COUNT=$((FILE_COUNT + 1))
            echo "  üñ•Ô∏è Adding desktop report"
          fi
          
          if [ -f lighthouse-tablet-report.zip ] && [ -s lighthouse-tablet-report.zip ]; then
            CURL_CMD="$CURL_CMD -F 'files[$FILE_COUNT]=@lighthouse-tablet-report.zip;filename=lighthouse-tablet-report.zip'"
            FILE_COUNT=$((FILE_COUNT + 1))
            echo "  üì± Adding tablet report"
          fi
          
          # Add the JSON payload with the embed
          CURL_CMD="$CURL_CMD -F 'payload_json=<discord-payload.json'"
          CURL_CMD="$CURL_CMD $WEBHOOK_URL"
          
          echo ""
          echo "Sending $FILE_COUNT file(s) with embed to Discord..."
          
          # Execute the curl command
          eval $CURL_CMD
          
          echo ""
          echo "‚úì Discord notification sent successfully with $FILE_COUNT attachment(s)"